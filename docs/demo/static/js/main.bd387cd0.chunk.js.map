{"version":3,"sources":["../../es256k-jws-ts/dist/esm5/JWS.js","App.js","serviceWorker.js","index.js","../../es256k-jws-ts/dist/esm5/keyUtils.js","../../lds-ecdsa-secp256k1-2019/dist/esm5/index.js","../../lds-ecdsa-secp256k1-2019/dist/esm5/createVerifyData/index.js"],"names":["Buffer","tslib__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","base64url__WEBPACK_IMPORTED_MODULE_1__","base64url__WEBPACK_IMPORTED_MODULE_1___default","n","bitcoin_ts__WEBPACK_IMPORTED_MODULE_2__","crypto__WEBPACK_IMPORTED_MODULE_3__","crypto__WEBPACK_IMPORTED_MODULE_3___default","_keyUtils__WEBPACK_IMPORTED_MODULE_4__","JWSVerificationFailed","_super","message","_this","call","this","name","Error","__webpack_exports__","decode","jws","options","complete","_a","split","encodedHeader","encodedPayload","encodedSignature","header","JSON","parse","a","payload","signature","sign","privateKeyJWK","alg","undefined","privateKeyUInt8Array","secp256k1","toBeSigned","digest","messageHashUInt8Array","signatureUInt8Array","signatureHex","label","Object","sent","encode","stringify","from","createHash","update","toString","signMessageHashCompact","signDetached","b64","crit","toBeSignedBuffer","concat","buffer","byteOffset","length","verify","publicKeyJWK","publicKeyUInt8Array","_b","toBuffer","verifySignatureCompact","verifyDetached","indexOf","privateJWK","crv","d","kid","kty","x","y","publicJWK","signatureOptions","challenge","created","domain","proofPurpose","verificationMethod","doc","@context","action","schema","App","state","JWS","ES256K","hello","verified","setState","EcsdaSecp256k1Signature2019","ldSig","lsSigVerified","react_default","createElement","className","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","privateKeyUInt8ArrayFromJWK","publicKeyUInt8ArrayFromJWK","_trust_keyto__WEBPACK_IMPORTED_MODULE_1__","_trust_keyto__WEBPACK_IMPORTED_MODULE_1___default","bitcoin_ts__WEBPACK_IMPORTED_MODULE_4__","privateKeyHexFromJWK","jwk","publicKeyHexFromJWK","uncompressedPublicKey","compressed","compressPublicKey","privateKeyHex","publicKeyHex","_createVerifyData__WEBPACK_IMPORTED_MODULE_1__","_transmute_es256k_jws_ts__WEBPACK_IMPORTED_MODULE_2__","privateKeyJwk","framed","verifyDataHexString","verifyDataBuffer","type","proof","publicKeyJwk","crypto__WEBPACK_IMPORTED_MODULE_1__","crypto__WEBPACK_IMPORTED_MODULE_1___default","jsonld__WEBPACK_IMPORTED_MODULE_2__","jsonld__WEBPACK_IMPORTED_MODULE_2___default","canonize","data","sha256","h","cannonizeSignatureOptions","_signatureOptions","signatureValue","proofValue","cannonizeDocument","_doc","expanded","cannonizedSignatureOptions","hashOfCannonizedSignatureOptions","cannonizedDocument","hashOfCannonizedDocument","creator","Date","toISOString","expand","compact","skipExpansion"],"mappings":"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","file":"static/js/main.bd387cd0.chunk.js","sourcesContent":["var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport base64url from 'base64url';\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\nimport crypto from 'crypto';\nimport { privateKeyUInt8ArrayFromJWK, publicKeyUInt8ArrayFromJWK } from './keyUtils';\n/** error matching @panva/jose for JWS verification failure. */\n\nvar JWSVerificationFailed =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(JWSVerificationFailed, _super);\n\n  function JWSVerificationFailed(message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.name = 'JWSVerificationFailed';\n    return _this;\n  }\n\n  return JWSVerificationFailed;\n}(Error);\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\n\n\nexport var signDetached = function signDetached( // in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\npayload, privateKeyJWK, header) {\n  if (header === void 0) {\n    header = {\n      alg: 'ES256K',\n      b64: false,\n      crit: ['b64']\n    };\n  }\n\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var privateKeyUInt8Array, secp256k1, encodedHeader, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , privateKeyUInt8ArrayFromJWK(privateKeyJWK)];\n\n        case 1:\n          privateKeyUInt8Array = _a.sent();\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 2:\n          secp256k1 = _a.sent();\n          encodedHeader = base64url.encode(JSON.stringify(header));\n          toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);\n          message = Buffer.from(toBeSignedBuffer);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);\n          signatureHex = binToHex(signatureUInt8Array);\n          encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n          return [2\n          /*return*/\n          , encodedHeader + \"..\" + encodedSignature];\n      }\n    });\n  });\n};\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\n\nexport var verifyDetached = function verifyDetached(jws, payload, publicKeyJWK) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var _a, encodedHeader, encodedSignature, header, publicKeyUInt8Array, secp256k1, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (jws.indexOf('..') === -1) {\n            throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n          }\n\n          _a = jws.split('..'), encodedHeader = _a[0], encodedSignature = _a[1];\n          header = JSON.parse(base64url.decode(encodedHeader));\n\n          if (header.alg !== 'ES256K') {\n            throw new Error('JWS alg is not signed with ES256K.');\n          }\n\n          if (header.b64 !== false || !header.crit || !header.crit.length || header.crit[0] !== 'b64') {\n            throw new Error('JWS Header is not in rfc7797 format (not detached).');\n          }\n\n          return [4\n          /*yield*/\n          , publicKeyUInt8ArrayFromJWK(publicKeyJWK)];\n\n        case 1:\n          publicKeyUInt8Array = _b.sent();\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 2:\n          secp256k1 = _b.sent();\n          toBeSignedBuffer = Buffer.concat([Buffer.from(encodedHeader + '.', 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]);\n          message = Buffer.from(toBeSignedBuffer);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));\n          verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);\n\n          if (verified) {\n            return [2\n            /*return*/\n            , true];\n          }\n\n          throw new Error('Cannot verify detached signature.');\n      }\n    });\n  });\n};\n/** Produce a normal ES256K JWS */\n\nexport var sign = function sign(payload, privateKeyJWK, header) {\n  if (header === void 0) {\n    header = {\n      alg: 'ES256K'\n    };\n  }\n\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var privateKeyUInt8Array, secp256k1, encodedHeader, encodedPayload, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , privateKeyUInt8ArrayFromJWK(privateKeyJWK)];\n\n        case 1:\n          privateKeyUInt8Array = _a.sent();\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 2:\n          secp256k1 = _a.sent();\n          encodedHeader = base64url.encode(JSON.stringify(header));\n          encodedPayload = base64url.encode(JSON.stringify(payload));\n          toBeSigned = encodedHeader + \".\" + encodedPayload;\n          message = Buffer.from(toBeSigned);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);\n          signatureHex = binToHex(signatureUInt8Array);\n          encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n          return [2\n          /*return*/\n          , encodedHeader + \".\" + encodedPayload + \".\" + encodedSignature];\n      }\n    });\n  });\n};\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\n\nexport var verify = function verify(jws, publicKeyJWK) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var secp256k1, publicKeyUInt8Array, _a, encodedHeader, encodedPayload, encodedSignature, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 1:\n          secp256k1 = _b.sent();\n          return [4\n          /*yield*/\n          , publicKeyUInt8ArrayFromJWK(publicKeyJWK)];\n\n        case 2:\n          publicKeyUInt8Array = _b.sent();\n          _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];\n          toBeSigned = encodedHeader + \".\" + encodedPayload;\n          message = Buffer.from(toBeSigned);\n          digest = crypto.createHash('sha256').update(message).digest().toString('hex');\n          messageHashUInt8Array = hexToBin(digest);\n          signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));\n          verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);\n\n          if (verified) {\n            return [2\n            /*return*/\n            , JSON.parse(base64url.decode(encodedPayload))];\n          }\n\n          throw new JWSVerificationFailed('signature verification failed');\n      }\n    });\n  });\n};\n/** decode a JWS (without verifying it) */\n\nexport var decode = function decode(jws, options) {\n  if (options === void 0) {\n    options = {\n      complete: false\n    };\n  }\n\n  var _a = jws.split('.'),\n      encodedHeader = _a[0],\n      encodedPayload = _a[1],\n      encodedSignature = _a[2];\n\n  if (options.complete) {\n    return {\n      header: JSON.parse(base64url.decode(encodedHeader)),\n      payload: JSON.parse(base64url.decode(encodedPayload)),\n      signature: encodedSignature\n    };\n  }\n\n  return JSON.parse(base64url.decode(encodedPayload));\n};\nexport default {\n  decode: decode,\n  sign: sign,\n  signDetached: signDetached,\n  verify: verify,\n  verifyDetached: verifyDetached\n};","import React from 'react';\n\nimport * as ES256K from '@transmute/es256k-jws-ts';\n\nimport * as EcsdaSecp256k1Signature2019 from '@transmute/lds-ecdsa-secp256k1-2019';\n\nconst privateJWK = {\n  crv: 'secp256k1',\n  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw',\n  kty: 'EC',\n  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n};\n\nconst publicJWK = {\n  crv: 'secp256k1',\n  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw',\n  kty: 'EC',\n  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n};\n\nconst signatureOptions = {\n  challenge: 'abc',\n  created: '2019-01-16T20:13:10Z',\n  domain: 'example.com',\n  proofPurpose: 'authentication',\n  verificationMethod: 'https://example.com/i/alice/keys/2',\n};\nconst doc = {\n  '@context': {\n    action: 'schema:action',\n    schema: 'http://schema.org/',\n  },\n  action: 'AuthenticateMe',\n};\n\nclass App extends React.Component {\n  state = {\n    JWS: '',\n  };\n  async componentWillMount() {\n    const jws = await ES256K.JWS.sign(\n      {\n        hello: 'world',\n      },\n      privateJWK\n    );\n    const verified = await ES256K.JWS.verify(jws, publicJWK);\n    this.setState({\n      jws,\n      verified,\n    });\n\n    const ldSig = await EcsdaSecp256k1Signature2019.sign(\n      doc,\n      signatureOptions,\n      privateJWK\n    );\n\n    const lsSigVerified = await EcsdaSecp256k1Signature2019.verify(\n      ldSig,\n      publicJWK\n    );\n\n    this.setState({\n      ldSig,\n      lsSigVerified,\n    });\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <h4>ES256K</h4>\n\n        <h5>Public Key</h5>\n        <pre>{JSON.stringify(publicJWK, null, 2)}</pre>\n\n        <h5>JWS</h5>\n        <code>{this.state.jws}</code>\n\n        <h5>Verified Payload</h5>\n        <code>{JSON.stringify(this.state.verified, null, 2)}</code>\n\n        <hr />\n\n        <h5>JSON-LD Signature</h5>\n        <pre>{JSON.stringify(this.state.ldSig, null, 2)}</pre>\n\n        <h5>Verified JSON-LD Signature</h5>\n        <code>{JSON.stringify(this.state.lsSigVerified, null, 2)}</code>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\nimport stringify from 'json-stringify-deterministic';\nvar compressedHexEncodedPublicKeyLength = 66;\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.\n */\n\nexport var getKid = function getKid(jwk) {\n  var copy = tslib_1.__assign({}, jwk);\n\n  delete copy.d;\n  delete copy.kid;\n  delete copy.alg;\n  var digest = crypto.createHash('sha256').update(stringify(copy)).digest();\n  return base64url.encode(Buffer.from(digest));\n};\n/** convert compressed hex encoded private key to jwk */\n\nexport var privateJWKFromPrivateKeyHex = function privateJWKFromPrivateKeyHex(privateKeyHex) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var jwk, kid;\n    return tslib_1.__generator(this, function (_a) {\n      jwk = tslib_1.__assign({}, keyto.from(privateKeyHex, 'blk').toJwk('private'), {\n        crv: 'secp256k1'\n      });\n      kid = getKid(jwk);\n      return [2\n      /*return*/\n      , tslib_1.__assign({}, jwk, {\n        kid: kid\n      })];\n    });\n  });\n};\n/** convert compressed hex encoded public key to jwk */\n\nexport var publicJWKFromPublicKeyHex = function publicJWKFromPublicKeyHex(publicKeyHex) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var secp256k1, key, jwk, kid;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 1:\n          secp256k1 = _a.sent();\n          key = publicKeyHex;\n\n          if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n            key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));\n          }\n\n          jwk = tslib_1.__assign({}, keyto.from(key, 'blk').toJwk('public'), {\n            crv: 'secp256k1'\n          });\n          kid = getKid(jwk);\n          return [2\n          /*return*/\n          , tslib_1.__assign({}, jwk, {\n            kid: kid\n          })];\n      }\n    });\n  });\n};\n/** convert pem encoded private key to jwk */\n\nexport var privateJWKFromPrivateKeyPem = function privateJWKFromPrivateKeyPem(privateKeyPem) {\n  var jwk = tslib_1.__assign({}, keyto.from(privateKeyPem, 'pem').toJwk('private'), {\n    crv: 'secp256k1'\n  }); // console.log(jwk);\n\n\n  var kid = getKid(jwk);\n  return tslib_1.__assign({}, jwk, {\n    kid: kid\n  });\n};\n/** convert pem encoded private key to jwk */\n\nexport var publicJWKFromPublicKeyPem = function publicJWKFromPublicKeyPem(publicKeyPem) {\n  var jwk = tslib_1.__assign({}, keyto.from(publicKeyPem, 'pem').toJwk('public'), {\n    crv: 'secp256k1'\n  });\n\n  var kid = getKid(jwk);\n  return tslib_1.__assign({}, jwk, {\n    kid: kid\n  });\n};\n/** convert jwk to hex encoded private key */\n\nexport var privateKeyHexFromJWK = function privateKeyHexFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    return tslib_1.__generator(this, function (_a) {\n      return [2\n      /*return*/\n      , keyto.from(tslib_1.__assign({}, jwk, {\n        crv: 'K-256'\n      }), 'jwk').toString('blk', 'private')];\n    });\n  });\n};\n/** convert jwk to hex encoded public key */\n\nexport var publicKeyHexFromJWK = function publicKeyHexFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var secp256k1, uncompressedPublicKey, compressed;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , instantiateSecp256k1()];\n\n        case 1:\n          secp256k1 = _a.sent();\n          uncompressedPublicKey = keyto.from(tslib_1.__assign({}, jwk, {\n            crv: 'K-256'\n          }), 'jwk').toString('blk', 'public');\n          compressed = secp256k1.compressPublicKey(hexToBin(uncompressedPublicKey));\n          return [2\n          /*return*/\n          , binToHex(compressed)];\n      }\n    });\n  });\n};\n/** convert jwk to binary encoded private key */\n\nexport var privateKeyUInt8ArrayFromJWK = function privateKeyUInt8ArrayFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var privateKeyHex;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , privateKeyHexFromJWK(jwk)];\n\n        case 1:\n          privateKeyHex = _a.sent();\n          return [2\n          /*return*/\n          , hexToBin(privateKeyHex)];\n      }\n    });\n  });\n};\n/** convert jwk to binary encoded public key */\n\nexport var publicKeyUInt8ArrayFromJWK = function publicKeyUInt8ArrayFromJWK(jwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var publicKeyHex;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , publicKeyHexFromJWK(jwk)];\n\n        case 1:\n          publicKeyHex = _a.sent();\n          return [2\n          /*return*/\n          , hexToBin(publicKeyHex)];\n      }\n    });\n  });\n};\nexport default {\n  binToHex: binToHex,\n  getKid: getKid,\n  hexToBin: hexToBin,\n  privateJWKFromPrivateKeyHex: privateJWKFromPrivateKeyHex,\n  privateJWKFromPrivateKeyPem: privateJWKFromPrivateKeyPem,\n  privateKeyHexFromJWK: privateKeyHexFromJWK,\n  privateKeyUInt8ArrayFromJWK: privateKeyUInt8ArrayFromJWK,\n  publicJWKFromPublicKeyHex: publicJWKFromPublicKeyHex,\n  publicJWKFromPublicKeyPem: publicJWKFromPublicKeyPem,\n  publicKeyHexFromJWK: publicKeyHexFromJWK,\n  publicKeyUInt8ArrayFromJWK: publicKeyUInt8ArrayFromJWK\n};","var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport createVerifyData from './createVerifyData';\nimport { JWS } from '@transmute/es256k-jws-ts';\n/**\n * Example\n * ```ts\n * const privateJWK = {\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw',\n *  kty: 'EC',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n * };\n * const signatureOptions = {\n *    challenge: 'abc',\n *    created: '2019-01-16T20:13:10Z',\n *    domain: 'example.com',\n *    proofPurpose: 'authentication',\n *    verificationMethod: 'https://example.com/i/alice/keys/2',\n * };\n * const doc = {\n *    '@context': 'https://w3id.org/identity/v1',\n *    title: 'Hello World!',\n * };\n *\n * const signed = await sign(doc, signatureOptions, privateJWK);\n * ```\n *\n * This functions takes a json-ld document, signature options,\n * and a JWK private key, and returns the document with a proof attribute.\n */\n\nexport var sign = function sign(payload, signatureOptions, privateKeyJwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var options, _a, framed, verifyDataHexString, verifyDataBuffer, jws, documentWithProof;\n\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          options = tslib_1.__assign({}, signatureOptions, {\n            type: 'EcdsaSecp256k1Signature2019'\n          });\n          return [4\n          /*yield*/\n          , createVerifyData(payload, options)];\n\n        case 1:\n          _a = _b.sent(), framed = _a.framed, verifyDataHexString = _a.verifyDataHexString;\n          verifyDataBuffer = Buffer.from(verifyDataHexString, 'hex');\n          return [4\n          /*yield*/\n          , JWS.signDetached(verifyDataBuffer, privateKeyJwk)];\n\n        case 2:\n          jws = _b.sent();\n          documentWithProof = tslib_1.__assign({}, framed, {\n            proof: tslib_1.__assign({}, options, {\n              jws: jws\n            })\n          });\n          return [2\n          /*return*/\n          , documentWithProof];\n      }\n    });\n  });\n};\n/**\n * Example\n * ```ts\n * const publicJWK = {\n *   crv: 'secp256k1',\n *   kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw',\n *   kty: 'EC',\n *   x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *   y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n * };\n * const signed = {\n *   '@context': 'https://w3id.org/security/v2',\n *   'http://schema.org/action': 'AuthenticateMe',\n *   proof: {\n *     challenge: 'abc',\n *     created: '2019-01-16T20:13:10Z',\n *     domain: 'example.com',\n *     proofPurpose: 'authentication',\n *     verificationMethod: 'https://example.com/i/alice/keys/2',\n *     type: 'EcdsaSecp256k1Signature2019',\n *     jws: 'eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..QgbRWT8w1LJet_KFofNfz_TVs27z4pwdPwUHhXYUaFlKicBQp6U1H5Kx-mST6uFvIyOqrYTJifDijZbtAfi0MA'\n *   }\n * }\n *\n * const verified = await verify(signed, publicJWK);\n * ```\n *\n * This functions takes a signed json-ld document, and JWK public key and\n * returns true if the document was signed by the public key, false otherwise.\n */\n\nexport var verify = function verify(payload, publicKeyJwk) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var verifyDataHexString, verifyDataBuffer;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , createVerifyData(payload, payload.proof)];\n\n        case 1:\n          verifyDataHexString = _a.sent().verifyDataHexString;\n          verifyDataBuffer = Buffer.from(verifyDataHexString, 'hex');\n          return [2\n          /*return*/\n          , JWS.verifyDetached(payload.proof.jws, verifyDataBuffer, publicKeyJwk)];\n      }\n    });\n  });\n};\nexport default {\n  sign: sign,\n  verify: verify\n};","var _this = this;\n\nimport * as tslib_1 from \"tslib\";\nimport crypto from 'crypto';\nimport jsonld from 'jsonld';\n\nvar canonize = function canonize(data) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    return tslib_1.__generator(this, function (_a) {\n      return [2\n      /*return*/\n      , jsonld.canonize(data)];\n    });\n  });\n};\n\nvar sha256 = function sha256(data) {\n  var h = crypto.createHash('sha256');\n  h.update(data);\n  return h.digest('hex');\n};\n\nvar cannonizeSignatureOptions = function cannonizeSignatureOptions(signatureOptions) {\n  var _signatureOptions = tslib_1.__assign({}, signatureOptions, {\n    '@context': 'https://w3id.org/security/v2'\n  });\n\n  delete _signatureOptions.jws;\n  delete _signatureOptions.signatureValue;\n  delete _signatureOptions.proofValue;\n  return canonize(_signatureOptions);\n};\n\nvar cannonizeDocument = function cannonizeDocument(doc) {\n  var _doc = tslib_1.__assign({}, doc);\n\n  delete _doc.proof;\n  return canonize(_doc);\n};\n/**\n * Example\n * ```ts\n * const signatureOptions = {\n *    challenge: 'abc',\n *    created: '2019-01-16T20:13:10Z',\n *    domain: 'example.com',\n *    proofPurpose: 'authentication',\n *    verificationMethod: 'https://example.com/i/alice/keys/2',\n * };\n * const doc = {\n *    '@context': 'https://w3id.org/identity/v1',\n *    title: 'Hello World!',\n * };\n *\n * const verifyData = await createVerifyData(doc, signatureOptions);\n * expect(verifyData).toEqual({\n *    framed: {\n *      '@context': 'https://w3id.org/security/v2',\n *      'dc:title': 'Hello World!',\n *    },\n *    verifyDataHexString:\n *      '16ec94c1612c48b916bae6002db32df122e8c20d0fee156778c630e51f0cb3cb9ac6f24c9632f44d7c5752c5eed022f226c8ddb535ad2420d8852c9798f89175',\n * });\n * ```\n * This functions takes a json-ld document and signature options,\n * and produces the hex encoded data used by json-ld signature suite.\n * See [create-verify-hash-algorithm](https://w3c-dvcg.github.io/ld-signatures/#create-verify-hash-algorithm)\n */\n\n\nvar createVerifyData = function createVerifyData(data, signatureOptions) {\n  return tslib_1.__awaiter(_this, void 0, void 0, function () {\n    var options, expanded, framed, cannonizedSignatureOptions, hashOfCannonizedSignatureOptions, cannonizedDocument, hashOfCannonizedDocument;\n    return tslib_1.__generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          options = tslib_1.__assign({}, signatureOptions);\n\n          if (options.creator) {\n            options.verificationMethod = signatureOptions.creator;\n          }\n\n          if (!options.verificationMethod) {\n            throw new Error('signatureOptions.verificationMethod is required');\n          }\n\n          if (!options.created) {\n            options.created = new Date().toISOString();\n          }\n\n          return [4\n          /*yield*/\n          , jsonld.expand(data)];\n\n        case 1:\n          expanded = _a.sent()[0];\n          return [4\n          /*yield*/\n          , jsonld.compact(expanded, 'https://w3id.org/security/v2', {\n            skipExpansion: true\n          })];\n\n        case 2:\n          framed = _a.sent();\n          return [4\n          /*yield*/\n          , cannonizeSignatureOptions(options)];\n\n        case 3:\n          cannonizedSignatureOptions = _a.sent();\n          hashOfCannonizedSignatureOptions = sha256(cannonizedSignatureOptions);\n          return [4\n          /*yield*/\n          , cannonizeDocument(framed)];\n\n        case 4:\n          cannonizedDocument = _a.sent();\n          hashOfCannonizedDocument = sha256(cannonizedDocument);\n          return [2\n          /*return*/\n          , {\n            framed: framed,\n            verifyDataHexString: hashOfCannonizedSignatureOptions + hashOfCannonizedDocument\n          }];\n      }\n    });\n  });\n};\n\nexport default createVerifyData;"],"sourceRoot":""}